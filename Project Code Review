Group Member Information:

Name: Simin Cheng, Student ID: 1663732, Email: sc1040@students.waikato.ac.nz
Name: Bai Lu, Student ID: 1671298, Email: ys677@students.waikato.ac.nz
Name: Ziqi Lin, Student ID: 1674249, Email: zl354@students.waikato.ac.nz
Name: Zhengrong Chen, Student ID: 1660321, Email: zc199@students.waikato.ac.nz

1.1 Systematic Issues
1.1.1 Cross-timezone and Internationalization Architecture Defects
Core Issue: The entire system lacks unified timezone handling strategy and internationalization resource management, causing incorrect data display for cross-regional users and language switching failures.
Impact Scope: Affects 3 core modules (workout logs, body measurements, gallery), 4 API endpoints, all non-English users (particularly 100% of Chinese users unable to use).
Key Evidence:

WorkoutLog.date uses datetime.datetime.now (wger/manager/models/log.py:55, commit 9a321b7, 2024-03-07)
Measurement.date and GalleryImage.date similarly use naive time (wger/measurements/models/measurement.py:47, wger/gallery/models/image.py:42, commit 7646416, 2021-07-08)
Weight reminder command uses datetime.datetime.now() (wger/weight/management/commands/email-weight-reminder.py:48)
Chinese directory removed but config not synced (locale/zh_CN exists but config points to zh-hans, commit 0fe9a6c removed, 97d95e2 updated config)

Root Cause Analysis:

Historical Evolution: Project evolved from 2013 single-machine Django to distributed deployment, but time handling logic never upgraded
Technical Debt: 9-year-old cache design (2015) still in use, not considering Python 3.3+ hash() randomization
Process Gap: Language resources deleted in 2021, config updated in 2023 without verifying resource integrity
Knowledge Transfer: Different contributors repeatedly introduce same issues, lacking timezone handling best practices documentation

Improvement Recommendations:

Immediate fix: Unify use of django.utils.timezone.now(), establish CI checks for naive time
Short-term: Fix language directory mapping, add resource integrity tests
Long-term: Establish timezone/i18n architecture documentation and code review checklist

1.1.2 Data Integrity Guarantee Mechanism Deficiency
Core Issue: Critical business logic relies on application-layer conventions and magic constants, lacking database-level constraints and type safety guarantees.
Impact Scope: Affects 5 core models, 15+ API endpoints, all sorting and unit conversion functions.
Key Evidence:

Day/Slot/SlotEntry have indexes but no unique constraints (wger/manager/models/day.py:45-78, slot.py:19-57, slot_entry.py:86-152, commits 49bbd18, 6f54568, 2024)
RepetitionUnit uses self.id == 1 for judgment (wger/core/models/rep_unit.py:55-61, commit 02279ee, 2021-06-23)
WorkoutLog.str hardcodes "kg" (wger/manager/models/log.py:234-235, commit a434c73, 2024-01-27)
JSONField lacks schema validation (wger/manager/models/day.py:99-106, slot.py:44-51, commit 30c14310, 2024-10-29)

Root Cause Analysis:

Design Philosophy Bias: "Performance first, constraints second" development culture, adding indexes without constraints
Technical Debt Accumulation: 2021 magic numbers persist, 2024 still adding hardcoding
Architecture Review Missing: JSONField transformation went live without schema design review
Insufficient Test Coverage: git grep "unique_together" returns empty, never considered database constraints

Improvement Recommendations:

Immediate fix: Add models.UniqueConstraint(fields=['routine', 'order']), data migration to clean duplicates
Short-term: Introduce enums to replace magic numbers, add Pydantic validation to JSONField
Long-term: Establish data model design standards, enforce schema-first development

1.1.3 Multi-process Cache Architecture Failure
Core Issue: Cache design remains in single-process era, key generation and invalidation strategies completely fail in distributed environments.
Impact Scope: All cache-dependent functions unreliable in multi-process deployment, affecting 90% of API responses.
Key Evidence:

Default LocMemCache config unchanged for 12 years (wger/settings_global.py:310-316, commit cfb0196, 2013-06-29)
Uses Python hash() for unstable keys (wger/utils/cache.py:43-47, commit 805b7cd, 2015-02-17)
reset_routine_cache only clears current process (wger/manager/helpers.py:185-203, commit f7d22e2, 2024-10-28)

Root Cause Analysis:

Historical Baggage: 2013 Django didn't support distributed, default config persists
Knowledge Blind Spot: Python 3.3 randomization not understood, hash() misused for 9 years
Scenario Change: 2024 new features still assume single-process, unaware production changed
Documentation Gap: Deployment docs don't require Redis/Memcached, defaults misused

Improvement Recommendations:

Immediate fix: Use f'{user_pk}:{year}:{month}:{day}' stable keys
Short-term: Default to Redis, add multi-process cache tests
Long-term: Establish cache strategy guide, performance benchmarks

1.1.4 N+1 Queries and Performance Degradation
Core Issue: Lacks systematic query optimization strategy, core functions have severe N+1 problems.
Impact Scope: PDF export time increased 300%, Routine page load triggers 17+ SQL queries.
Key Evidence:

Day.get_slots_* uses getattr(self, 'prefetched_slots', self.slots.all()) fallback queries (wger/manager/models/day.py:147-177)
Test code doesn't cover prefetch scenarios (wger/manager/tests/test_day.py:19-123, commit 065d432)
PDF export queries Exercise.objects.get(pk=...) individually (wger/manager/helpers.py:95-135)
Cache invalidation deeply traverses entire Routine tree (wger/manager/helpers.py:185-203)

Root Cause Analysis:

Partial Optimization: prefetch only used in Routine.get_date_sequence, other code not updated
Test Quality: Tests use direct .get(pk=1), not simulating actual usage
Performance Awareness: Lacks batch thinking, individual queries during deep traversal
Monitoring Gap: No performance benchmarks, degradation occurs silently

Improvement Recommendations:

Immediate fix: Provide Routine.objects.with_full_structure() unified prefetch
Short-term: Add Django Debug Toolbar for N+1 detection
Long-term: Establish performance benchmark suite

1.1.5 Permission Model Interface Chaos
Core Issue: Permission checking interface lacks unified contract for 10 years, creating security risks.
Impact Scope: All REST API permission validation, third-party extension integration.
Key Evidence:

WgerOwnerObjectModelViewSet assumes obj.get_owner_object().user (wger/utils/viewsets.py:16-41, commit 3dab6fd, 2014)
WorkoutLog returns self, Day returns routine, RepetitionUnit returns None (wger/manager/models/log.py:237-241, day.py:119-123, wger/core/models/rep_unit.py:47-52)
No formal interface definition or documentation for 10 years

Root Cause Analysis:

Interface Evolution Chaos: 2014 design, 2021-2024 individual implementations, no unified standard
Contract Missing: get_owner_object() lacks formal definition, implementers freestyle
Review Blind Spot: None return issue undetected for years, permission checks may be bypassed
Extensibility Gap: Didn't consider third-party models, security risks exist

Improvement Recommendations:

Immediate fix: Define interface contract, handle None returns
Short-term: Audit all model implementations, supplement permission tests
Long-term: Establish API version management strategy




1.2 Positive Design Choices
Meta Ordering and Indexes in Models
Example: Day.Meta.ordering = ['order'] with order indexed.
Benefits: Database directly returns sorted rows, reducing ORM overhead. This is a best practice for read-heavy workloads (e.g., dashboards). Particularly in PostgreSQL, B-tree indexes can directly support ORDER BY operations, avoiding additional sorting steps.
Developer impact: Query code remains concise—no repetitive order_by(). For example, Day.objects.filter(routine=r) automatically returns sorted results without needing Day.objects.filter(routine=r).order_by('order'), reducing error potential. Performance remains consistent even with large routines.
Centralized React View Handling
Example: wger/core/views/react.ReactView encapsulates authentication checks, template selection, and Shadow DOM exceptions.
Benefits: Enforces DRY principle and standardizes the bootstrap process for every React page. All React pages share the same security checks, CSRF token handling, and initial data injection logic. When authentication logic needs modification or new security headers are added, only one place needs updating.
Developer impact: Introducing new screens requires less boilerplate. New developers only need to inherit ReactView and override get_context_data() to create new pages, without understanding the underlying Shadow DOM compatibility handling. Bugs in the base view fix all consumers simultaneously.
Using Dataclasses for Template-ready Data
Example: wger/manager/dataclasses.SlotData aggregates data for templates.
Benefits: Separates data marshalling from presentation, making the Python layer responsible for shape transformations. Dataclasses provide automatic __init__, __repr__, and __eq__ methods, reducing boilerplate. Type annotations make data structures clear, and IDEs can provide accurate autocomplete.
Developer impact: Templates remain clean—using {{ slot.start_time }} instead of {{ slot.0.1.time }} greatly improves readability. View tests can validate structure via dataclasses. Unit tests can directly construct SlotData instances for testing without mocking complex model relationships. IDE type hints remain accurate throughout development.



2. Contribution Summary
Issue #1980 - Fix Workout Day Ordering Issue [Zhengrong Chen]

Repository: https://github.com/liebeziv/wger/tree/fix-training-day-order
Pull Request: https://github.com/wger-project/wger/pull/2050

Problem: Workout days occasionally render out of order (Monday after Wednesday), especially for locales where the backend returns Sunday as the first element.
Actual development process: Initially thought it was a CSS issue, tried adjusting display order with CSS order property, but realized this was only visual modification—the data order itself was wrong. Then considered fixing at the backend API level, but this required modifying multiple endpoints with too large an impact. Next attempted directly modifying wger/core/static/react/main.js, finding the dayDataCurrentIteration location in the compressed code and adding .slice().sort(...) logic. Local testing indeed solved the problem, excitedly submitted PR #2050. It was rejected—maintainer pointed out shouldn't modify compiled files. Only then realized React code has a separate source repository. After finding wger-react repository, reimplemented in src/components/WorkoutRoutines/models/Routine.ts, designing a stable comparator: first by day.order, then by date, finally by day.id as tiebreaker. This process took two weeks, mainly wasted understanding the project's build pipeline.
Maintainer interaction: After submitting PR #2050, received no direct maintainer reply. PR was closed, the issue was modifying the compiled bundle file rather than source code. Currently reimplementing the fix in the React source repository.
Outcome: Rejected - Attempting to initiate secondary fixes within the React repository

Issue #2019 - Implement Calories Burned Feature [Zhengrong Chen]

Repository: https://github.com/liebeziv/wger/tree/feature-calories
Pull Request: Not yet submitted

Problem: Users want workouts to auto-compute calories and sync with nutrition plans.
Actual development process: Started thinking it was simple—just add a "Calories" unit to RepetitionUnit table. Added REP_UNIT_CALORIES = 3 in wger/manager/consts.py, then wrote migration script to insert new record. Testing revealed the problem: calories aren't fixed values like weight, same exercise burns differently for different people. Started redesigning, realized need: an ExerciseCalorieData model storing base burn rates for each exercise; calculations adjusted by user weight and age; integration with nutrition plans. Wrote extensive design documentation, using bilingual (fearing unclear expression) description in the issue. Maintainer replied automatic calculation too complex, accuracy hard to guarantee, suggested considering smartwatch sync. Now stuck—have model definitions and migration scripts locally, but haven't figured out core calculation service. Considering whether to implement simple version first (manual calorie input), then gradually add automatic calculation.
Maintainer interaction: Proposed complete implementation plan in issue #2019. Maintainer @rolandgeider replied: "adding kcal as units for workouts is a good idea" but expressed concerns about automatic calculations, noting need to add data for each exercise in database and uncertainty about accuracy. He suggested considering smartwatch sync (issue #618) as more precise alternative.
Outcome: In development - backend models and migration scaffold exist locally.
Issue #1105 - Add Guide Arrow for Empty State Page [Bai Lu]

Pull Request: https://github.com/wger-project/react/pull/1105
Personal fork test: https://github.com/vilanell000/react/pull/1

Problem: When users first enter the empty routine overview page, it's unclear how to start creating their first routine. The page has an add button (FAB), but new users might miss it (related issue #1103).
Actual development process:
Phase 1: Personal fork experiment
Conducted initial development and testing in personal fork, creating complete implementation of animated responsive arrow. This version contained all functional features as proof of concept.
Phase 2: Formal submission (PR #1105)

Created an animated arrow pointing to the add button in OverviewEmpty component
Created fabRef reference and passed it to OverviewEmpty and AddRoutineFab in RoutineOverview
Implemented responsive animated arrow from prompt text to add button
Modified fabRef type to HTMLElement for type safety
Added animation effects to make arrow more prominent, improving user discovery rate

Maintainer interaction: Maintainer @rolandgeider commented thanking for the PR, but explained he adopted a different solution in PR #1113—adding action buttons in all template overviews that can prefill templates and public flags, and allow editing existing user templates. He felt although action buttons might be somewhat "lost" at the edge position, the solution might be aligning them with main content.
Outcome: Closed unmerged - maintainer adopted alternative solution (PR #1113).
Issue #1117 - Exercise Search Save Button Visual Feedback [Bai Lu]

Pull Request: https://github.com/wger-project/react/pull/1117

Problem: Users have no visual feedback when saving search queries, unsure if operation succeeded.
Root cause analysis:

Save button has no visual feedback after click, users unsure if operation is processing
Success or failure status has no clear indication
Users might click repeatedly during network delays, causing multiple submissions

Actual development process:
Initial design attempted to make save button flash red after click, using CSS animation for pulse effect, but testing found effect too strong.
Iterative improvements based on maintainer feedback:

The initial design attempted to make the save button turn red and blink when clicked, using CSS animation to achieve a pulsing effect, but testing revealed that the effect was too strong and could cause users to mistake it for an error message. Based on the feedback suggestions from the maintainers, a more moderate visual feedback scheme was implemented: disable the button to prevent repeated clicks when the query is running, display a green tick mark (✅) for 2 seconds after success, and use the project's existing FormQueryErrors component to display an error message when it fails. At the same time, a 300ms anti-shaking mechanism was added to avoid frequent requests and ensure that all error messages are clear and easy to understand.


Maintainer interaction: Maintainer @rolandgeider commented: "Adding some feedback is definitely a good idea, the feature itself would need to be added to ExerciseSearchForm" but noted red flashing effect was "too much". Adjusted UI implementation three times according to project specifications.
Outcome: Awaiting review - visual feedback enhancement complete but awaiting final approval.
Issue #1108 - Nutrition Table Calculation Inaccuracy Due to Rounding [Simin Cheng]

Repository: https://github.com/simin-ch/react/tree/nutrition-precision-feature
Pull Request: In preparation

Problem: Nutrition tables display inaccurate totals due to premature rounding. Root cause is numberUnitLocale function in src/utils/numbers.ts has maximumFractionDigits: 0, forcing all nutritional values to be rounded to integers before calculation.
Root cause analysis:

numberGramLocale function calls numberUnitLocale with hardcoded maximumFractionDigits: 0. This configuration forces all nutritional values to display as integers (rounded to whole numbers), while actual calculations are performed using precise stored values.
Nutritional data is actually stored with 3 decimal places precision in the database.

Actual development process:

Phase 1: Fix number display function - Modified numberGramLocale function in src/utils/numbers.ts to accept precision setting, removed hardcoded maximumFractionDigits: 0, created new numberConfigurable function to display decimals when needed.
Phase 2: Add toggle to tables - Added precision toggle buttons to nutrition tables, used React's useState to control integer or decimal display, added simple toggle buttons with icons and help text.
Phase 3: Create global settings - Built global system using React Context to save precision settings across the app, added localStorage to remember user choices between browser sessions.
Phase 4: Connect all components - Updated all nutrition tables to use global precision settings instead of their own local settings, used useNutritionPrecision hook to share same precision choice everywhere.
Phase 5: Add controls to main pages - Wrapped React app with precision provider, added toggle buttons to main nutrition pages, ensured all nutrition displays use same precision setting.
Phase 6: Create reusable button - Made standard PrecisionToggleButton component that looks and works the same everywhere, added precision control to more places like ingredient details, and improved help text.

Maintainer interaction: Detailed the calculation inaccuracy caused by rounding in issue #1108, awaiting maintainer feedback.
Outcome: In development - awaiting documentation polish before submission.
Issue #1115 - Meal Form Time Field Not Editable [Simin Cheng]

Repository: https://github.com/simin-ch/react/tree/fix-timepicker-bug
Pull Request: https://github.com/wger-project/react/pull/1116

Problem: In the "Add Meal" form, the time field cannot be properly edited or selected. Users cannot modify time when adding or editing meals, severely impacting meal logging functionality.
Root cause: TimePicker component in MealForm.tsx receives Luxon DateTime object, but onChange handler directly passes Luxon DateTime object to Formik, which expects JavaScript Date object. This type mismatch prevents proper form state updates.
Actual development process: Solution was to convert returned Luxon DateTime back to JS Date before saving to Formik. Added conversion in onChange handler: formik.setFieldValue('time', value.toJSDate()). Although fix was simple, finding this cause took two hours of debugging.
Maintainer interaction: When submitting PR #1116, explained root cause: Formik expects JS Date but received Luxon DateTime. Maintainer @rolandgeider responded quickly: "I had barely seen your original issue and you directly open this PR 😄" and merged the fix 5 days ago.
Outcome: Merged - deployed to production.

Issue #1122
Repository: https://github.com/simin-ch/react/tree/feature/fab-alignment
Pull Request: https://github.com/wger-project/react/pull/1125
Problem: The floating action button (FAB) currently snaps to the right edge of the viewport. On wider displays this leaves it visually detached from the central layout, making it harder for users to notice and reach.
Root cause: Every FAB uses position: fixed with right: theme.spacing(2) (16px). The main layout is wrapped in <Container maxWidth="lg"> (1200px), so once the viewport is wider than 1200px, the content stays centered but the FAB remains fixed to the screen edge, breaking alignment.
Actual development process:
1) Inspected the shared FAB components and confirmed they were position: fixed with right: theme.spacing(2) pinned to the viewport edge.
2)Reviewed the layout: content sits inside a centered <Container maxWidth="lg">, so wide viewports leave the FAB detached.
3)Calculated how far the container is from the screen edge and proposed an updated sx.right using max(${theme.spacing(2)}, calc((100vw - ${theme.breakpoints.values.lg}px) / 2 + ${theme.spacing(2)})).
4)Applied that change across all FAB components, then manually tested at narrow and wide widths to ensure the FAB hugs the content on large screens while still keeping a 16px margin on small ones.
Maintainer interaction: PR received maintainer approval and was merged after submission.
Outcome: Merged - deployed to production.

Issue #2040 - Language Dropdown Overflow on Small Screens [Ziqi Lin]

Repository: https://github.com/Carner-Lin/wger/tree/language-dropdown
Pull Request: https://github.com/wger-project/wger/pull/2042

Problem: Footer language dropdown extends beyond viewport on small windows, making top entries inaccessible. Users cannot scroll inside dropdown to access hidden languages.
Root cause:

Dropdown has no max height or scrolling behavior; its height grows with content.
Menu relies on default Bootstrap styles; on small screens, absolute/fixed positioning doesn't constrain panel within viewport.

Actual development process: Added specific CSS class to dropdown <ul> in template and introduced lightweight stylesheet, limiting menu height to viewport-relative value (max-height: 60vh) and enabling vertical scrolling (overflow-y: auto). Also limited width to avoid horizontal overflow and applied overscroll-behavior: contain so scroll gestures are captured by menu instead of leaking to page behind. Through these adjustments, menu now always remains fully usable on small screens: all languages accessible by scrolling inside dropdown.
Maintainer interaction: PR received maintainer approval and was merged after submission.
Outcome: Merged - deployed to production.
Issue #2030 - Prevent Negative Height Values in Preferences [Ziqi Lin]

Repository: https://github.com/Carner-Lin/wger/tree/Height-limit
Pull Request: https://github.com/wger-project/wger/pull/2030

Problem: The "Height (cm)" input allowed negative values via spinner in user preferences.
Root cause:

1. Model lacked a server-side validator to forbid negatives.
2. Form widget missed HTML constraints (min="0"), so the browser spinner could go below 0.

Actual development process: At the form layer, I set type="number", step="1", and min="0", which makes the spinner stop at zero and prompts a native “must be ≥ 0” message when the user types a negative number.
Negative numbers are now prohibited for "height" in personal profile.
Maintainer interaction: PR accepted and merged by maintainer after submission.
Outcome: Merged - deployed to production.

Issue #1120 - Layout Misalignment Causes Thumbnails to Obscure Text [Ziqi Lin]

Repository: https://github.com/Carner-Lin/react/tree/routine-layout-fixes
Pull Request: https://github.com/wger-project/react/pull/1121

Problem: On routine page, as window width gradually decreases, distance between exercise thumbnail and text also decreases, causing it to obscure text.
Root cause:

Left "thumbnail column" isn't fixed; under flex wrapping it shrinks or reflows, allowing image to drift.
Right "text column" maintains its minimum content width, so it doesn't shrink, effectively pushing the image.

Actual development process: Made row a non-wrapping flex/grid container so image and text stay on same line, gave left column fixed, non-shrinking width. Also allowed right column to actually shrink and wrap by explicitly permitting width compression, so long titles wrap within their own column instead of displacing image. Then kept multiple thumbnails vertically stacked with small, consistent gap for visual rhythm. After changes, thumbnail column remains fixed at left across breakpoints, text wraps naturally within its area, and overlap/covering issue no longer occurs on phones or when desktop window is resized.
Maintainer interaction: PR reviewed and merged by maintainer after submission.
Outcome: Merged - deployed to production.
3. Lessons Learned
Submit changes to the right repository - Workout ordering fix was initially applied to compiled JavaScript bundle. Maintainers rightly rejected it and clarified all React changes must be proposed in wger-react repository. This experience highlighted importance of understanding build pipelines before submitting patches.
Design communication matters - For calorie automation feature, presenting bilingual, structured plan made it easier for maintainers to give feedback. Even though feature is still under development, aligning ideas early prevented significant rework.
Incremental wins build trust - Although Bai Lu's guide arrow feature (PR #1105) wasn't merged, it demonstrated thinking about user experience. Maintainer adopted different solution but acknowledged problem existence and need for improvement.
Testing and reproducibility go hand-in-hand - For frontend layout fixes (language dropdown, routine thumbnails), attaching screenshots and responsive design notes reduced ambiguity and built reviewer confidence without requiring them to manually reproduce environment. Ziqi Lin's three merged PRs prove effectiveness of this approach.
Understand project alternatives - Bai Lu's guide arrow being replaced by alternative solution shows importance of discussing design approaches with maintainers before implementation to avoid duplicate work.
